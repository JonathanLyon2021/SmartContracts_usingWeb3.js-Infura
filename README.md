# SmartContracts_usingWeb3.js-Infura
This is Exercise 15 in MI4 of Kingsland Universities Blockchain Developer Program

# Overview
Web3.js is a collection of libraries which allow you to interact with a local or remote Ethereum node using an HTTP
or IPC connection. In this exercise, we will use web3.js to deploy a contract on the Ethereum Ropsten testnet and
play with it. We will first compile a contract, deploy it and finally call some of the contract’s functions. In order for
web3 to connect to the Ropsten testnet, we will use Infura.io API as our provider.

# Goals
• Using Web3.js, interface with Ethereum’s Ropsten Network via Infura.io.
• Using Web3.js, call smart contract methods.

# Prerequisites
• NodeJS v16.15.0
• NPM v7.19.1
• Solc v0.8.13
• Web3 v3.0.0-rc.5

# Problem 1. Dependency Installation

To start with, create a new project on your preferred directory.
In the directory, open a terminal and initialize a NodeJS project:
  
    npm init –y

After that, install solc-js:

    npm install solc@0.8.13

Last but not least, web3.js:

    npm install web3@3.0.0-rc.5

## Problem 1. Dependency Installation
To start with, create a new project on your preferred directory.
In the directory, open a terminal and initialize a NodeJS project:

    npm init –y
    
After that, install solc-js:

    npm install solc@0.8.13
    
Last but not least, web3.js:

    npm install web3@3.0.0-rc.5

## Problem 3. Compiling the Smart Contract
The Smart Contract object is a meta-class. What this means is that functions in it are not defined until it is
instantiated with an application binary interface (ABI) which is usually generated by a compiler, such as the Solidity
compiler solc is used to generate JavaScript bindings for the Solidity compiler.
Now, implement an ArrayOfFacts smart contract which stores a string array of facts in the blockchain. Only the
owner of the contract can add facts, but anyone can count how many facts there are and get a fact by index.

Now that the smart contract has been implemented, go back to app.js. Read the contract and store it in a variable.

Compile the contract.
Implement the **standardCompilerInput** which contains compilation instructions for the colc compiler. 
Then, compile the contract via solc.compile)_ and access the object that we are interested in.

Open a terminal on your project folder and run the following command, then examine the output.

    node app.js
    
## 1. Deploy a Smart Contract
Now that we have compiled our ArrayOfFacts.sol smart contract, it is time to deploy it on the Ropsten Testnet.
Retrieve one private key from MetaMask and use it as a signer for the deployment transaction. This account will also
be the contract owner.

If you do not have ETH, use the Goerli faucet: https://goerlifaucet.com/
Export the private key (DO NOT USE an account that holds actual mainnet ETH):

Save the exported privateKey in your app.js file. Don’t forget to prefix the copied key with 0x.

To deploy a contract to the Ethereum Network, two things are required:

• The contract’s bytecode
• The contract’s application binary interface (ABI)
Both are generated from the Solidity compilation process. We already have this from an earlier step and this is
stored on our compiledContract variable.
Import the account in web3 using the private key we got from an earlier step (see Line 37).
Then, use web3.eth.Contract(jsonInterface [, address] [, options]), which will initialize a contract with all its
methods defined in the json interface object.
Since this is a deployment operation, we do not have an existing contract address of an already deployed contract to
interact with yet. Leave this parameter as null.
Then, add the following as additional options:
• data – the bytecode of the contract,
• gas – the maximum gas provided for a transaction (gas limit)
• from – the address from which the transaction should be made.
Finally, call the initialized contract’s deploy() function.
If everything goes well, the promise resolves with a new contract instance and sends the transaction. When the
deployment is successful, that means the transaction is mined. The callback function will print the contract address:

Run app.js and you’ll get the deployed contract address.

Verify that the contract has indeed been deployed at the Goerli Test Network by visiting:
https://goerli.etherscan.io/address/REPLACE-THIS WITH YOUR-DEPLOYED-CONTRACT-ADDRESS

If for some reason the transaction takes longer than expected, you may receive an error message. But your contract
is still deployed and you can find it by following the address from which you deployed it in Ropsten explorer.

